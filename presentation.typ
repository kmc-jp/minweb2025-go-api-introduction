#set text(lang: "ja")
#set text(font: "Noto Sans Javanese")

#set heading(numbering: none)

#import "@preview/slydst:0.1.5" : *

#show: slides.with(
  title: "Web API講座",
  authors: "48th irom",
)

#outline()

= HTTPの基礎

== HTTPとは
- HyperText Transfer Protocolの略
- WebブラウザとWebサーバーが通信するためのルール
- クライアント（リクエスト）とサーバー（レスポンス）の間でデータのやり取りを行う

== HTTPリクエストとレスポンス
- **リクエスト**: クライアントからサーバーへの要求
  - メソッド、URI、ヘッダー、ボディで構成される
- **レスポンス**: サーバーからクライアントへの応答
  - ステータスコード、ヘッダー、ボディで構成される

== HTTPヘッダー
- リクエストやレスポンスに関する付加情報（メタデータ）
- キーと値のペアで記述される
- 例:
  - `Content-Type`: データの形式（`application/json`など）
  - `Authorization`: 認証情報

== HTTPボディとJSON
- **ボディ**: 実際に送受信されるデータ本体
- **JSON (JavaScript Object Notation)**:
  - Web APIで最も一般的に使われるデータ形式
  - 軽量で人間にも読みやすいテキスト形式
  - キーと値のペアでデータを表現する

= REST

== REST API
- **REpresentational State Transfer** の略
- Webシステムを設計するためのアーキテクチャスタイル
- 分散システムにおいて、効率的でスケーラブルな通信を実現するための指針

== リソース指向アーキテクチャ(ROA)
- 「リソース（情報）」を中心に考える設計思想
- 全てのリソースに固有の識別子（URI）を与える
- HTTPメソッドを使ってリソースを操作する

== RESTfulなシステムの制約条件

- クライアントとサーバーの分離
- ステートレス性
- キャッシュ可能性
- 階層化システム
- コードオンデマンド
- 統一インターフェース

== クライアントとサーバーの分離
- UI（クライアント）とデータ保存（サーバー）の関心を分離する
- 互いに独立して進化・開発できるようになる
- マルチプラットフォーム対応が容易になる

== ステートレス性
- サーバーはクライアントの状態（セッション状態など）を保存しない
- すべてのリクエストは、それだけで処理が完結するよう必要な情報をすべて含める必要がある
- スケーラビリティ（拡張性）が向上する

== キャッシュ可能性
- レスポンスはキャッシュ可能かどうかを明示する
- クライアントがデータを再利用することで、通信量を減らし、レスポンス速度を向上させる

== 階層化システム
- クライアントはサーバーに直接接続しているか、中間のプロキシ等に接続しているか意識しない
- ロードバランサなどを挟むことで負荷分散やセキュリティ向上が可能

== コードオンデマンド
- サーバーからクライアントにプログラム（JavaScriptなど）を送って実行させる機能
- クライアントの機能を拡張できる（APIでは必須ではない場合が多い）

== 統一インターフェース
- 構成要素間のインターフェースを統一する
- URIの形式やHTTPメソッドの使い方を標準化することで、システム全体がシンプルになる

== リソース(URI)設計
- リソースは「名詞」で表現する（動詞は使わない）
- 複数形を使うのが一般的
- 階層構造で関係性を表す
- 例: `GET /tasks` (タスク一覧), `GET /tasks/1` (タスク詳細)

== パスパラメータ
- リソースを一意に特定するためにURIの一部として埋め込む値
- 例: `/tasks/1` の `1`
- 特定のデータを取得・更新・削除する場合に使用する

== クエリパラメータ
- リソースに対する操作の条件を指定するために使う
- URIの末尾に `?key=value` の形式で付与
- フィルタリング、ソート、ページネーションなどに使用
- 例: `/tasks?status=done&limit=10`

= HTTPメソッドとCRUD操作

== GET
- リソースの **取得 (Read)**
- サーバーのデータを変更しない
- 例: タスク一覧の取得、タスク詳細の取得

== POST
- リソースの **新規作成 (Create)**
- ボディに作成するデータを含めて送信する
- 例: 新しいタスクの登録

== PUT / PATCH
- リソースの **更新 (Update)**
- **PUT**: リソース全体を置き換える
- **PATCH**: リソースの一部を変更する
- 例: タスクの内容変更、完了状態の更新

== DELETE
- リソースの **削除 (Delete)**
- 指定されたリソースを削除する
- 例: タスクの削除

== ステータスコード
- 処理結果を表す3桁の数字
- **2xx (成功)**: `200 OK`, `201 Created`
- **4xx (クライアントエラー)**: `400 Bad Request`, `401 Unauthorized`, `404 Not Found`
- **5xx (サーバーエラー)**: `500 Internal Server Error`

== 冪等性と安全性
- **安全性 (Safe)**: 操作によってリソースの状態が変わらないこと (GET)
- **冪等性 (Idempotent)**: 同じ操作を何度繰り返しても結果が変わらないこと (GET, PUT, DELETE)
- POSTは冪等ではない（連打すると複数作成される可能性がある）

= アーキテクチャと設計

== 責務の分離
- コードを役割ごとに分割して管理する
- メリット:
  - 可読性の向上
  - テストの容易性
  - 変更の影響範囲を限定できる

== レイヤードアーキテクチャ
- Handler (Controller): HTTPリクエストの受付
- Service (UseCase): ビジネスロジック
- Repository: データアクセス

== Handler
- **役割**: HTTP通信の窓口
- リクエストパラメータの受け取りとバリデーション
- Service層の呼び出し
- レスポンス（JSONなど）の返却
- ビジネスロジックは書かない

== Service
- **役割**: ビジネスロジックの実装
- 「アプリケーションが何をするか」を記述
- データの加工、計算、複数リポジトリの操作など
- 特定のWebフレームワークに依存させないのが理想

== Repository
- **役割**: データの永続化
- データベース(DB)へのアクセスを担当
- SQLの実行やORMの操作
- 保存先がDBでもファイルでも、Service層への影響を最小限にする

== データ構造
- **Model (Entity)**: データベースの構造を表す
- **DTO (Data Transfer Object)**: APIの入出力専用のデータ構造
- 内部のデータ構造とAPIのインターフェースを分離するために使い分ける

== Model
- DBのテーブル定義と1対1で対応する構造体
- GormなどのORMで使用するタグを含むことが多い
- データベースの都合（外部キーなど）が含まれる

== DTO
- クライアントからのリクエスト受け取りや、レスポンス返却に使う構造体
- 必要なデータのみを定義する
- バリデーションタグなどを付与する
- クライアントに見せたくない情報（パスワードハッシュなど）を除外できる

= GoとGinによる実装

== Go言語
- Googleが開発したプログラミング言語
- 静的型付け、コンパイル言語、高速な実行速度
- 並行処理（Goroutine）が強力
- シンプルな文法

== Gin フレームワーク
- Go言語用の高速なHTTP Webフレームワーク
- ルーティング、ミドルウェア、JSONバリデーションなどの機能を提供
- パフォーマンスが高く、API開発によく使われる

== Ginの基本フロー
1. ルーターの作成 (`gin.Default()`)
2. ミドルウェアの設定（CORSなど）
3. ルーティングの定義（URLとハンドラの紐付け）
4. サーバーの起動 (`r.Run()`)

== ルーティングとグループ化
- HTTPメソッドとURLパスに対して、実行する関数を指定する
- **グループ化**: 共通のパスプレフィックスやミドルウェアをまとめる機能
  - 例: `v1 := r.Group("/api/v1")`
  - `/api/v1/tasks`, `/api/v1/users` のように整理できる

== リクエストのバインディングとバリデーション
- `ShouldBindJSON`: リクエストボディのJSONをGoの構造体に変換
- 構造体のタグ (`binding:"required"` 等) で入力チェックを自動化
- 型が違う場合や必須項目がない場合はエラーになる

== レスポンスのエラーハンドリング
- エラーが発生した場合、適切なステータスコードを返す
- `c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})`
- エラーレスポンスの形式を統一しておくと、クライアント側が扱いやすい

== 依存性注入 (Dependency Injection)
- Handlerが使うService、Serviceが使うRepositoryを外部から渡す設計
- `main`関数などで依存関係を組み立てる
- インターフェースを利用することで、テスト時にモック（偽物）への差し替えが容易になる